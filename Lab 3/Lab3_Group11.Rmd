---
title: "732A90: Computational Statistics"
subtitle: "Computer lab3 - Group11"
author: "Sofie Jörgensen, Oriol Garrobé Guilera, David Hrabovszki"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  pdf_document:
      fig_caption: yes
header-includes:
- \usepackage{float}
---

```{r setup, include=FALSE, eval=TRUE, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Question 1: Cluster sampling

```{r, echo=FALSE, warning=FALSE}
# R version
RNGversion('3.5.1')
#libraries
library(ggplot2)
```


### 1.

```{r}
# Question 1: Cluster sampling
# 1.1
data <- read.csv2("population.csv",sep=";")
data$Prob <- data$Population / sum(data$Population)
```

### 2. 
```{r}

```


# Question 2: Different distributions

In this question we are given the double exponential (Laplace) distribution with the location parameter $\mu$ and the scale parameter $\alpha$, where the formula is given by

$$DE(\mu,\alpha) = \frac{\alpha}{2} \text{exp}(-\alpha|x-\mu|).$$


### 1.

The aim of this task is to generate random numbers from a double exponential distribution with $\mu=0$ and $\alpha=1$, that is $DE(0, 1)$, from a uniform distribution $\text{Unif}(0, 1)$ by using the inverse CDF method. For this, we will generate 10000 random numbers, and a plot histogram of the results. 


Let, 
$$X \stackrel{}\sim DE(0,1)$$

Then,
$${f_x}(x) = \frac{1}{2} exp(-|x|) $$

Also,
$${F_x}(x) = \int_{-\infty}^{x} {f_x}(s)ds = \frac{1}{2} exp(-|s|)ds$$
Therefore,

$$
{F_x}(x) = \begin{cases} \frac{exp(x)}{2} ,x < 0 \\ 1 - \frac{exp(-x)}{2}, x \geq 0 \end{cases}
$$

!!!QUESTION: Here I only use the function for x>0. Should we do it for bigger and smaller than 0????? !!!!

Using the CDF method we look for $F^{-1}_{x}$, which is:
$$F^{-1}_{x}(y) = -ln(2-2y) $$


Hence, if $U\stackrel{}\sim U(0,1)$, then
$$-ln(2-2U) = X \stackrel{}\sim DE(0,1)$$

Using this formula bla bla...
```{r}
uniform <- runif(1000, min = 0, max = 1) #Not allowed, use from ex.1
DE_numbers <- -log(2 - 2 * uniform)
hist(DE_numbers, breaks = 30)
```

The histogram looks like an exponential??? 

### 2.

Now we are going to apply the Acceptance/Rejection method by using the double exponential distribution obtained from Question 2.1, in order to generate standard normal variables. In other words, $DE(0,1)$ is the majorizing density $f_Y$ and $N(0,1)$ is the target density $f_X$. The implementation of the Acceptance/Rejection method is taken from the example in the course material provided in the lecture. From Figure X (refer to histogram in Question 2.1) we can observe that the shape of the distribution looks quite similar to a standard normal distribution since it is centered around zero and have a similar spread, thus the choice of the $DE(0,1)$ can be considered as reasonable. 


The idea is to generate a random number from $DE(0,1)$, i.e. $Y \sim f_Y$ and a random number from $U \sim\text{Unif}(0,1)$. Then if $U\leq \frac{f_X(Y)}{cf_Y(Y)}$ holds, then we accept the generated number $Y$, otherwise it is rejected. The rejection is controlled by the majorizing constant $c$, and a value of $c$ closer to 1 will imply fewer rejections. This means that if $c=1$, then $f_Y$ and $f_X$ are the same density function. Thus we wish to pick a majorizing constant c, close to 1 such that it fulfills the requirement that $c\cdot f_Y (x) \geq f_X(x)$ for all $x$. We test a sequence of numbers of $c$ from $1$ to $5$, and obtained 1.32 as the smallest $c$ such that the requirement is still fulfilled for any $x$. 

Thereafter we generate $2000$ standard normal random numbers with this setting. The result is presented in a histogram in Figure X. In the Acceptance/Rejection method, we compute the number of rejections $R$ with \texttt{num.reject} and we obtain $R=0.317$ for $c=1.32$. The number of rejections plus the single draw, when the random number is accepted, must equal the total number of draws. Since the total number of draws is Geometric distributed with mean $c$, the expected rejection rate $ER$ is given by $c-1= 1.32-1=0.32$. By computing the difference $ER-R = 0.003$ we can conclude that the expected rejection rate $ER$ and the average rejection rate $R$ are very close to each other. Also, the two histograms looks similar when comparing Figure X with Figure X for $2000$ random numbers. Hence we are satisfied with our implemented random generator. 


```{r, echo=FALSE}
#Need to use 2.1 for 2.2
# Remove this later or add to 2.1

# Random numbers from DE(0,1) from Unif(0,1) generated by using the inverse cumulative function.
# Divide the two cases into different statements. 
my_DE <- function(n){
  x <- c()
  for (i in 1:n){
    u <- runif(1)
    if(u < 0.5){
      x[i] <- log(2*u)
    }else{
      x[i] <- -log(2*(1-u))
    }
  }
  return(x)
}

```


```{r, echo=FALSE}
# 2.2
# Acceptance/Rejection method
# Function that generates N(0,1) by using the majorizing density DE(0,1)
# The code is obtained from "732A90_ComputationalStatisticsVT2020_Lecture03codeSlide19.R"
fgennorm <- function(c){
  x <- NA
  num.reject <- 0
  while (is.na(x)){
    y <- my_DE(1) # majorizing density 
    u <- runif(1) # Unif(0,1)
    if (u <= dnorm(y)/(c*0.5*exp(-abs(y)))){x <- y}
    else{ num.reject <- num.reject + 1}
  }
  c(x, num.reject)
}

```

```{r,echo=FALSE}
# Set seed 
set.seed(12345)

# Number of generated numbers
n <- 2000
# Create a matrix that stores the random numbers and number of rejections
A <- matrix(c(rep(0,n) ,rep(0,n)), ncol = 2)

# Call the fgennorm function with c=3.12, based on the requirement.
for (i in 1:n){
  A[i,] <- fgennorm(1.32)
}

```

```{r,echo=FALSE}
# Histogram of 2000 generated random numbers N(0,1)
# by using the Acceptance/Rejection method
# with majorizing density DE(0,1)
hist(A[,1], breaks = 40)

```


```{r,echo=FALSE}
# Histogram of 2000 random N(0,1) numbers
hist(rnorm(2000), breaks = 40)

```


```{r,echo=FALSE, include=FALSE}
# Average rejection rate for c=1.32
mean(A[,2])

# Pick the smallest c, s.t. the requirement is still fulfilled
# Here the generated data with c=1.32 is used, but works the same for other values
nr <- A[,1] 
c_values <- seq(1,5,0.01)
for (i in seq_along(c_values)){
  if(all((c_values[i]*0.5*exp(-abs(nr)) >= dnorm(nr)))){
    c_value <- c_values[i]
    break()
  }
}

# Confirmes majorizing constant
all(c_value*0.5*exp(-abs(nr)) >= dnorm(nr))
table(c_value*0.5*exp(-abs(nr)) >= dnorm(nr))


```

