---
title: "Lab1 Group11"
author: "Sofie Jörgensen, Oriol Garrobé Guilera, David Hrabovszki"
date: "1/24/2020"
output: pdf_document
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Question 1: Be careful when comparing
In this task, we are given two R code snippets, each consisting of a comparision of rational numbers. The first code snippet compares $\frac{1}{3}-\frac{1}{4}$ with $\frac{1}{12}$, and the second code snippet compares $1-\frac{1}{2}$ with $\frac{1}{2}$. For both code snippets, the comparison is performed by the logical operator \texttt{==}, and prints an output, which is either "Subtraction is correct" or "Subtraction is wrong". The code snippets can be found in the Appendix. 

## 1. 

```{r echo = FALSE, warning=FALSE, include=FALSE}
#1.1
# First code snippet
x1 <- 1/3
x2 <- 1/4
if (x1-x2 == 1/12) {
  print("Subtraction is correct" )
} else {
    print("Subtraction is wrong")
}

# Second code snippet. 
x1 <- 1
x2 <- 1/2
if (x1-x2 == 1/2) {
  print("Subtraction is correct")
} else {
  print("Subtraction is wrong")
}
```

After running the two code snippets, we observe that the first snippet prints the output "Subtraction is wrong", while the second snippet prints "Subtraction is correct". In both cases, the comparisions should be mathematically correct, but since floats are rounded in R, the values $\frac{1}{3}$ and $\frac{1}{12}$ are not precisely represented. In other words, all the repeating decimals cannot be stored in R so the value is rounded. Since the snippets use the logical operator \texttt{==}, corresponding to exactly equality, this implies that the two sides in the second snippet are not precisely equal. Thus it will return "Subtraction is wrong".



## 2.

The code causes problems as already mentioned in Question 1, which confirmes that comparisons should be carried out carefully. One suggestion of improvement is to use the functions \texttt{all.equal()} and \texttt{isTRUE()}, instead of the logical operator \texttt{==}. The function \texttt{all.equal()} tests if two objects are nearly equal, in contrast to \texttt{==} which tests exact equality. The funciton \texttt{isTRUE()} is necessary to handle the \texttt{FALSE} result of \texttt{all.equal()} in the \texttt{if} statement. This improvement of the code snippet (see Appendix) prints "Subtraction is correct" when comparing $\frac{1}{3}-\frac{1}{4}$ with $\frac{1}{12}$, which is the mathematically correct output. 


```{r echo = FALSE, warning=FALSE, include=FALSE}
#1.2
# Suggestion of improvement
# using all.equal() and isTRUE()
x1 <- 1/3
x2 <- 1/4
if (isTRUE(all.equal(x1-x2, 1/12))) {
  print ("Subtraction is correct" )
} else {
  print ("Subtraction is wrong")
}
```


# Question 2

Using the definition of a derivative, we use the following formula at point $x$ with small $\epsilon$:

$f'(x)=\frac{f(x+\epsilon)-f(x)}{\epsilon}$


## 1.

We calculate the derivative of $f(x)=x$, with $\epsilon=10^{-15}$ using our own function (see Appendix).

```{r echo = FALSE}
#2.1

f <- function(x) x

epsilon <- 1e-15

derivative <- function(f, x, e){
  (f(x+epsilon) - f(x))/epsilon
} 


```

## 2. & 3.

Now we evaluate our derivative function at $x=1$ and $x=100000$ and obtain the following results:

```{r echo = FALSE}
#2.2 & 2.3

derivative(f, 1, epsilon)
derivative(f,100000, epsilon)
```

The true values of the derivatives are 1 for every $x$, and we expect our function to output a value close to 1.

The obtained derivative for $x=1$ is close to the true value, but for large $x$ we get the result 0.

If we consider x within the range [0,1[, we obtain approximately 1. The difference between large numbers, dominates the small epsilon, which gives us zero in the nominator and thus the derivative evaluated at large points is 0. In general, adding small numbers first will give a better accuracy, than adding large number first, which we are doing when using the definition of the derivative.

# Question 3

A known formula for estimating the variance based on a vector of n observations is

$Var(\vec{x})=\frac{1}{n-1}\Bigg{(}\sum^{n}\limits_{i=1}x^2_i-\frac{1}{n}\Big{(}\sum^{n}\limits_{i=1}x_i\Big{)}^2\Bigg{)}$

## 1.

Write your own R function, myvar, to estimate the variance in this way.

```{r}
RNGversion('3.5.1')

# Seed
set.seed(1234567890)
```

## 2.

Generate a vector $x=(x_1,...,x_{10000})$ with 10000 random numbers with mean $10^8$ and
variance 1.

## 3.

For each subset $X_i=\{x_1,...,x_i\},i=1,...,10000$ compute the difference $Y_i=myvar(X_i)-var(X_i)$, where $var(X_i)$ is the standard variance estimation function in R.

## 4.


# Question 4

## 1.

Import the data set to R.

```{r}
#4.1


```


## 2.

Optimal regression coefficients can be found by solving a system of the type 
$A\vec{\beta}=\vec{b}$ 
where 
$A=X^TX$
and 
$\vec{b}=X^T\vec{y}$
. The matrix 
$X$
are the
observations of the absorbance records, levels of moisture and fat, while 
$\vec{y}$
are the protein levels.

```{r}
#4.2


```


## 3.

Try to solve $A\vec{\beta}=\vec{b}$ with default solver solve().

```{r}
#4.3

```


## 4.

Check the condition number of the matrix $A$.

The condition number $\kappa$ of square matrix A is:
$||A||\space||A^{-1}||$

```{r}
#4.4

```


## 5.

Scale the data set and repeat steps 2-4.

```{r}
#4.5

```



# Appendix

```{r ref.label=knitr::all_labels(),echo=TRUE,eval=FALSE}

```
